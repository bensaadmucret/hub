{#
  Page de souscription utilisant Tailwind (déjà configuré dans le projet).
  - Pas de CDN CSS: on s'appuie sur base.html.twig qui inclut build/app.css.
  - Charge uniquement le script Paddle Billing v2 (requis pour le checkout côté client).
#}

{% extends 'base.html.twig' %}

{% block title %}Souscription{% endblock %}

{% block stylesheets %}
  {{ parent() }}
  {# S'assure que la CSS compilée est chargée si le layout ne le fait pas déjà #}
  <link rel="stylesheet" href="{{ asset('build/app.css') }}">
{% endblock %}

{% block body %}
  <main class="min-h-[60vh] bg-gray-50 py-12">
    <div class="container mx-auto px-4">
      <section class="mx-auto w-full max-w-xl rounded-xl border border-gray-200 bg-white p-8 shadow-sm">
        <div class="mb-6">
          <h1 class="text-3xl font-semibold tracking-tight text-gray-900">Souscription</h1>
          <p class="mt-2 text-sm text-gray-600">Accédez à l'abonnement via Paddle (création de session côté serveur).</p>
        </div>

        {% if paddle_price_id is empty %}
          <div class="mb-4 rounded-md border border-amber-300 bg-amber-50 px-4 py-3 text-amber-900">
            <p class="text-sm font-medium">PADDLE_PRICE_ID est manquant. Veuillez le définir dans votre .env.local.</p>
          </div>
        {% endif %}

        {% for message in app.flashes('error') %}
          <div class="mb-4 rounded-md border border-red-300 bg-red-50 px-4 py-3 text-red-900">
            <p class="text-sm font-medium">{{ message }}</p>
          </div>
        {% endfor %}
        
        <form id="subscribeForm" method="post" action="{{ path('subscribe_create') }}" class="flex items-center gap-3" data-turbo="false">
          <input type="hidden" name="_token" value="{{ csrf_token('subscribe_create') }}">
          <button
            {% if paddle_js_enabled %}type="button"{% else %}type="submit"{% endif %}
            id="subscribeBtn"
            class="inline-flex items-center justify-center rounded-md bg-indigo-600 px-5 py-2.5 text-sm font-medium text-white shadow-sm transition hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
            {% if paddle_price_id is empty %}disabled{% endif %}
          >
            <span>S’abonner</span>
          </button>
          <p class="text-sm text-gray-600">
            {% if paddle_price_id is empty %}
              Configurez le priceId (pri_...) pour activer le bouton.
            {% else %}
              Vous serez redirigé vers la page de paiement sécurisée.
            {% endif %}
          </p>
        </form>
      </section>
    </div>
  </main>
{% endblock %}

{% block javascripts %}
  {{ parent() }}
  {% if paddle_js_enabled %}
  <script src="https://cdn.paddle.com/paddle/v2/paddle.js" crossorigin="anonymous" data-turbo-eval="true" data-turbo-track="reload"></script>

  <script>
    function initPaddleCheckout() {
      const env = '{{ app_env|e('js') }}' || 'prod';
      const priceId = '{{ paddle_price_id|e('js') }}';
      const clientToken = '{{ paddle_client_token|default('')|e('js') }}';
      const customerEmail = '{{ customer_email|default('')|e('js') }}';

      const btn = document.getElementById('subscribeBtn');
      const spinner = document.getElementById('spinner');
      const statusMsg = document.getElementById('statusMsg');

      function setLoading(loading) {
        if (!btn) return;
        btn.disabled = !!loading;
        if (spinner) spinner.classList.toggle('hidden', !loading);
      }

      function setStatus(message, type = 'info') {
        if (!statusMsg) return;
        statusMsg.textContent = message || '';
        statusMsg.className = 'text-sm ' + (type === 'error' ? 'text-red-600' : 'text-gray-600');
      }

      function loadScriptOnce(src, id) {
        if (document.getElementById(id)) return;
        const s = document.createElement('script');
        s.id = id;
        s.src = src;
        s.async = true;
        s.defer = true;
        s.setAttribute('data-turbo-eval', 'true');
        s.setAttribute('data-turbo-track', 'reload');
        document.head.appendChild(s);
      }

      async function ensurePaddleReady() {
        // Attendre que le SDK (CDN) soit prêt
        let tries = 0;
        // Attendre jusqu'à ~5s pour le local (50 x 100ms)
        while (!window.Paddle && tries < 50) {
          await new Promise(r => setTimeout(r, 100));
          tries++;
        }
        // Fallback CDN si toujours absent
        if (!window.Paddle) {
          setStatus('SDK local indisponible, chargement du CDN Paddle…', 'info');
          loadScriptOnce('https://cdn.paddle.com/paddle/v2/paddle.js', 'paddle-sdk-cdn');
          let cdnTries = 0;
          while (!window.Paddle && cdnTries < 50) {
            await new Promise(r => setTimeout(r, 100));
            cdnTries++;
          }
        }
        if (!window.Paddle) throw new Error('Paddle SDK non chargé (local et CDN).');

        // Traces de présence SDK
        try {
          console.info('[Paddle] SDK chargé:', typeof window.Paddle, 'Checkout.open:', typeof window.Paddle?.Checkout?.open);
        } catch (_) {}

        // Initialisation stricte selon la doc
        if (typeof window.Paddle?.Initialize === 'function') {
          if (env === 'dev') {
            if (!clientToken) {
              const msg = 'Client token requis en sandbox (Paddle.Initialize). Définissez PADDLE_CLIENT_TOKEN dans .env.local';
              setStatus(msg, 'error');
              try { console.error('[Paddle] Initialize error:', msg); } catch (_) {}
              throw new Error(msg);
            }
            try {
              console.info('[Paddle] Initializing (sandbox) ...');
              window.Paddle.Initialize({ environment: 'sandbox', token: clientToken });
              console.info('[Paddle] Initialized (sandbox).');
            } catch (e) {
              const d = (e && (e.error?.message || e.message)) || String(e);
              try { console.error('[Paddle] Initialize failed (sandbox):', d, e); } catch (_) {}
              throw e;
            }
          } else {
            try {
              console.info('[Paddle] Initializing (production) ...');
              window.Paddle.Initialize({ environment: 'production' });
              console.info('[Paddle] Initialized (production).');
            } catch (e) {
              const d = (e && (e.error?.message || e.message)) || String(e);
              try { console.error('[Paddle] Initialize failed (production):', d, e); } catch (_) {}
              throw e;
            }
          }
        }
      }

      // Guard: invalid ID cases (missing or productId instead of priceId)
      const invalidId = !priceId || priceId.startsWith('pro_');
      if (btn) btn.disabled = invalidId;
      if (invalidId) {
        setStatus(!priceId
          ? 'Configuration manquante: priceId (pri_...)'
          : 'ID invalide: un productId (pro_...) a été fourni. Renseignez un priceId (pri_...)', 'error');
      }

      async function openCheckout() {
        setStatus('Clic détecté, vérification du SDK...', 'info');
        if (invalidId) {
          // Message déjà affiché via guard; on ne poursuit pas
          try { console.warn('[Paddle] Invalid priceId. Expected pri_...'); } catch (_) {}
          return;
        }
        try {
          setLoading(true);
          try { console.groupCollapsed('[Paddle] Checkout'); } catch (_) {}
          try {
            console.debug('[Paddle] Env:', env);
            console.debug('[Paddle] SDK presence:', typeof window.Paddle, typeof window.Paddle?.Checkout?.open);
          } catch (_) {}

          setStatus('Chargement du SDK Paddle...', 'info');
          await ensurePaddleReady();
          setStatus('SDK prêt, ouverture du checkout...', 'info');

          const items = [{ priceId: priceId, quantity: 1 }];
          const customer = customerEmail ? { email: customerEmail } : undefined;

          const options = {
            items,
            customer,
            successUrl: '/',
            closeCallback: () => { setLoading(false); },
          };

          try { console.debug('[Paddle] Checkout.open options:', { items, customer: customer ? { email: customer.email } : undefined, successUrl: options.successUrl }); } catch (_) {}

          if (window.Paddle && window.Paddle.Checkout && typeof window.Paddle.Checkout.open === 'function') {
            window.Paddle.Checkout.open(options);
            setStatus('Checkout ouvert avec succès', 'info');
            try { console.info('[Paddle] Checkout opened.'); } catch (_) {}
          } else {
            throw new Error(`API Checkout indisponible. SDK: ${typeof window.Paddle}, Checkout: ${typeof window.Paddle?.Checkout}, open: ${typeof window.Paddle?.Checkout?.open}`);
          }
        } catch (err) {
          const details = (err && (err.error?.message || err.message)) || String(err);
          try { console.error('[Paddle] Error:', details, err?.stack || err); } catch (_) {}
          setStatus(`Erreur Paddle: ${details}`, 'error');
          // Fallback: si le SDK échoue, bascule sur le flux server-side
          try {
            const form = document.getElementById('subscribeForm');
            if (form) {
              console.info('[Paddle] Fallback: submitting server-side form');
              form.submit();
              return;
            }
          } catch (_) {}
          setLoading(false);
        } finally {
          try { console.groupEnd(); } catch (_) {}
        }
      }

      if (btn) {
        // Garder le handler actif pour permettre plusieurs essais si SDK pas prêt
        btn.addEventListener('click', openCheckout);
      }
    }

    // Attendre que le DOM soit prêt et attacher l'event listener
    function attachEventListener() {
      console.log('[Paddle] Looking for button with ID: subscribeBtn');
      const button = document.getElementById('subscribeBtn');
      console.log('[Paddle] Button found:', button);
      if (button) {
        button.addEventListener('click', async function() {
          const env = '{{ app_env|e('js') }}' || 'prod';
          const priceId = '{{ paddle_price_id|e('js') }}';
          const clientToken = '{{ paddle_client_token|default('')|e('js') }}';
          const customerEmail = '{{ customer_email|default('')|e('js') }}';

          // Guard: invalid ID cases
          const invalidId = !priceId || priceId.startsWith('pro_');
          if (invalidId) {
            console.warn('[Paddle] Invalid priceId. Expected pri_...');
            return;
          }

        try {
          console.log('[Paddle] Button clicked, initializing...');
          
          // Attendre le SDK
          let tries = 0;
          while (!window.Paddle && tries < 50) {
            await new Promise(r => setTimeout(r, 100));
            tries++;
          }
          
          if (!window.Paddle) {
            console.error('[Paddle] SDK not loaded, falling back to server-side');
            document.getElementById('subscribeForm').submit();
            return;
          }

          // Initialiser Paddle
          if (typeof window.Paddle?.Initialize === 'function') {
            if (env === 'dev') {
              if (!clientToken) {
                console.error('[Paddle] Client token required in sandbox');
                document.getElementById('subscribeForm').submit();
                return;
              }
              window.Paddle.Initialize({ token: clientToken, pwCustomer: true });
            } else {
              window.Paddle.Initialize({ pwCustomer: true });
            }
          }

          // Ouvrir le checkout Paddle
          window.Paddle.Checkout.open({
            items: [{ priceId: priceId, quantity: 1 }],
            customer: customerEmail ? { email: customerEmail } : undefined,
            settings: {
              displayMode: 'overlay',
              theme: 'light',
              locale: 'fr',
              successUrl: '{{ url('subscribe_success') }}',
              closeUrl: '{{ url('subscribe_cancel') }}'
            }
          });
          console.log('[Paddle] Checkout opened');
        } catch (err) {
          console.error('[Paddle] Error:', err);
          document.getElementById('subscribeForm').submit();
        }
      });
      console.log('[Paddle] Event listener attached to button');
      return true;
    } else {
      console.error('[Paddle] Button not found');
      return false;
    }
    }

    // Essayer d'attacher l'event listener plusieurs fois si nécessaire
    let attached = attachEventListener();
    if (!attached) {
      // Réessayer après un délai court
      setTimeout(() => {
        attached = attachEventListener();
        if (!attached) {
          // Dernier essai avec DOMContentLoaded
          document.addEventListener('DOMContentLoaded', attachEventListener);
        }
      }, 100);
    }
  </script>
  {% endif %}
{% endblock %}
